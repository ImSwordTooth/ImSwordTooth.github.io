import{_ as i,c as n,f as s,b as a,ao as e,o as t}from"./chunks/framework.IeBF7J3I.js";const T=JSON.parse('{"title":"pc-site 说明","description":"","frontmatter":{},"headers":[],"relativePath":"pages/projects/pc-site.md","filePath":"pages/projects/pc-site.md","lastUpdated":1701308594000}'),l={name:"pages/projects/pc-site.md"},r=a("h1",{id:"pc-site-说明",tabindex:"-1"},[s("pc-site 说明 "),a("a",{class:"header-anchor",href:"#pc-site-说明","aria-label":'Permalink to "pc-site 说明"'},"​")],-1),p=a("p",null,[s("本项目为乐视网 PC 站。"),a("br"),s(`
重构之前使用 jQuery 的旧项目，使用服务端渲染来达到更快的加载速度和更好的 SEO。`)],-1),h=a("h3",{id:"技术栈",tabindex:"-1"},[s("技术栈 "),a("a",{class:"header-anchor",href:"#技术栈","aria-label":'Permalink to "技术栈"'},"​")],-1),d=e('<table tabindex="0"><thead><tr><th>类型</th> <th>说明</th></tr></thead> <tbody><tr><td>框架</td> <td>Vue 3</td></tr> <tr><td>CSS 预处理器</td> <td>less</td></tr> <tr><td>构建工具</td> <td>vite</td></tr> <tr><td>路由</td> <td><a href="https://router.vuejs.org/zh/" target="_blank" rel="noreferrer">Vue Router</a></td></tr> <tr><td>状态管理器</td> <td>没有使用 vuex，而是简单的 <a href="https://cn.vuejs.org/guide/scaling-up/state-management.html#what-is-state-management" target="_blank" rel="noreferrer">状态管理</a></td></tr> <tr><td>重要插件</td> <td><a href="https://antdv.com/components/overview-cn" target="_blank" rel="noreferrer">ant-design-vue</a><br><a href="https://cn.vite-plugin-ssr.com/" target="_blank" rel="noreferrer">vite-plugin-ssr</a></td></tr></tbody></table>',1),o=a("h3",{id:"ssr",tabindex:"-1"},[s("SSR "),a("a",{class:"header-anchor",href:"#ssr","aria-label":'Permalink to "SSR"'},"​")],-1),c=a("p",null,[s("本项目最值得一说的就是 SSR 部分。"),a("br"),s(`
服务端渲染可以加快访问速度，优化 SEO，是网站必需的能力。 一般的 SSR 都比较繁杂庞大，我这里基于 `),a("a",{href:"https://cn.vitejs.dev/",target:"_blank",rel:"noreferrer"},"vite"),s(" 和 "),a("a",{href:"https://cn.vite-plugin-ssr.com/",target:"_blank",rel:"noreferrer"},"vite-plugin-ssr"),s(" 开发了一套"),a("strong",null,"适合本项目"),s(`的服务端渲染流程。
只需添加很小的一部分服务端代码，其余部分都和客户端渲染共用代码。`)],-1),k=a("h4",{id:"基本流程",tabindex:"-1"},[s("基本流程 "),a("a",{class:"header-anchor",href:"#基本流程","aria-label":'Permalink to "基本流程"'},"​")],-1),_=a("p",null,[s("本项目的核心在 "),a("code",null,"/renderer"),s(" 文件夹内。")],-1),u=a("ul",null,[a("li",null,[a("code",null,"_default.page.client.js"),s(" 仅负责客户端渲染；")]),s(),a("li",null,[a("code",null,"_default.page.server.js"),s(" 仅负责服务端渲染；")]),s(),a("li",null,[a("code",null,"app.js"),s(" 同时负责客户端渲染和服务端渲染。")])],-1),g=e('<ol><li>先从 <code>_default.page.server.js</code> 中请求数据，这里根据路由匹配，所以要注意路由匹配的优先级，尽量和前端 router 里一致</li> <li>数据分为 <code>PageData</code> 和 <code>CommonData</code>，分别是页面特有的数据和公共数据</li> <li>获取到之后，放置在 <code>AllData</code> 里，通过插件的 api 传输到 <code>_default.page.client.js</code> 里</li> <li><code>_default.page.client.js</code> 获取到数据之后，用 <code>vue</code> 的 <a href="https://cn.vuejs.org/api/application.html#app-provide" target="_blank" rel="noreferrer">provide()</a> 方法，注入到应用的所有后代元素里。</li> <li>在业务组件中可以通过以下代码获取注入的数据</li></ol>',1),b=e(`<div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useSSRContext, inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 两个钩子可以不一致，比如只在客户端做的事，就没必要写在 serverPrefetch 里</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   serverPrefetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务端特有的生命周期钩子，这里是给服务端渲染准备的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">       this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.swiperList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSSRContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().PageData; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这里是获取页面特有的数据，如果组件是公共数据，那么就获取 CommonData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * 客户端特有的生命周期钩子，这里是给客户端端渲染准备的，建议使用 beforeMount</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * 之前用 mounted，发现经常会出现水和失败的提示，导致页面加载两次，是因为 mounted 之前就用 data 里的数据渲染一遍了，还没来得及用服务端的数据，所以和 ssr 的内容不一致。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   beforeMount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">       this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.swiperList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;AllData&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).PageData;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre> <div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="其他亮点" tabindex="-1">其他亮点 <a class="header-anchor" href="#其他亮点" aria-label="Permalink to &quot;其他亮点&quot;">​</a></h3>`,2),m=e(`<ol><li><strong>线上环境</strong>添加了服务端获取客户端 cookie 的方式，因此可以在服务器调用用户信息接口、会员接口等敏感信息，这样访问页面的时候不会有&quot;未登录&quot;或者&quot;非会员&quot;的中间状态一闪而过。<br>
但是本地开发的时候还挺麻烦。如果用 vite 的一般模式启动，没有向服务器发送 cookie 的地方。<br>
有一个方法可以用 vite 的中间件模式启动，自定义一个服务器，向 ssr 的 render 发送请求页面时的 cookie，就能达成目标。</li> <li>为方便调试和排查问题，服务端发出的请求都在客户端备份了一份，可通过 <code>window.__SSRR</code> 查找，里面存储了当前页面在服务端发出的请求的数组，只有在添加了特定的 url 参数才会生效，以免影响日常访问的 html 体积。</li> <li>使用了 <code>pre-commit</code> 钩子，每次 commit 之前检测特定文件下第一行的图标链接是否为第三方链接，如果是第三方的，就调用脚本上传为公司自己的链接，来达成外部链接私有化的目的。</li></ol>`,1);function E(f,y,v,A,D,S){return t(),n("div",null,[r,s(),p,s(),h,s(),d,s(),o,s(),c,s(),k,s(),_,s(),u,s(),g,s(),b,s(),m])}const F=i(l,[["render",E]]);export{T as __pageData,F as default};
