import{_ as e,o as c,c as o,d}from"./app-hBvoMyXQ.js";const a={},t=d('<h1 id="可装配上线步骤的上线系统-deploy" tabindex="-1"><a class="header-anchor" href="#可装配上线步骤的上线系统-deploy" aria-hidden="true">#</a> 可装配上线步骤的上线系统 - deploy</h1><p>公司旧有的上线系统操作繁琐，需要用户多次操作才能完成。<br> 并且结构固定，想要接入新的上线项目，必须要改源码才能完成。</p><p>于是本人做了一个新的系统。整理出一些通用的、可配置的步骤，制作成可直接使用的物料，新增或修改上线流程时可直接套用。<br> 技术点：<code>vue</code>、<code>webpack</code>、<code>OAuth 登录</code>、<code>MongoDB 存储数据</code>、<code>socket.io 建立连接</code>、<code>node-pty 流式传输</code></p><p><img src="https://i3.letvimg.com/lc16_lemf/202311/23/15/19/Snipaste_2023-11-23_15-18-17.png" alt="主页"></p><h3 id="一、登录" tabindex="-1"><a class="header-anchor" href="#一、登录" aria-hidden="true">#</a> 一、登录</h3><p>使用了<code>OAuth</code>连接到了 gitlab 登录，免去了手动登录的麻烦，也不用费心思琢磨公司用的 <strong>LDAP</strong> 登录</p><h3 id="二、项目列表、分支列表和-commit-列表" tabindex="-1"><a class="header-anchor" href="#二、项目列表、分支列表和-commit-列表" aria-hidden="true">#</a> 二、项目列表、分支列表和 commit 列表</h3><p>对于项目列表，因为“<strong>要上线的项目</strong>”和“<strong>我拥有的项目</strong>”不是同一个东西，因此放在数据库的表里。<br> 分支列表和 commit 列表则是通过<code>OAuth</code>获取到的 token，使用 gitlab 的 api 获取。</p><h3 id="三、上线步骤" tabindex="-1"><a class="header-anchor" href="#三、上线步骤" aria-hidden="true">#</a> 三、上线步骤</h3><p>上线步骤是本系统的核心概念。<br> 用户可以在“上线步骤” tab 里去增删改步骤。不管怎么改，只要符合规范，就能在不动源码的情况下，随意组合出大量复杂的、不同的上线流程。<br><img src="https://i3.letvimg.com/lc15_lemf/202311/23/16/26/Snipaste_2023-11-23_16-24-17.png" alt="上线步骤"><br> 步骤类型分为三种：</p><h4 id="_1-固定步骤" tabindex="-1"><a class="header-anchor" href="#_1-固定步骤" aria-hidden="true">#</a> 1.固定步骤</h4><p>预设的流程，一般用于数值、流程较为固定的步骤，比如克隆代码、<code>npm install</code>、<code>npm run build</code> 等<br><img src="https://i3.letvimg.com/lc16_lemf/202311/23/16/31/Snipaste_2023-11-23_16-29-20.png" alt=""></p><h4 id="_2-命令步骤" tabindex="-1"><a class="header-anchor" href="#_2-命令步骤" aria-hidden="true">#</a> 2.命令步骤</h4><p>可以输入要执行的 linux 命令，在服务器上直接执行填写的语句。<br> 如果命令中需要参数，本项目有一些预设的参数，如项目名称、选择的分支等。 <img src="https://i3.letvimg.com/lc14_lemf/202311/23/16/35/Snipaste_2023-11-23_16-35-40.png" alt=""></p><h4 id="_3-特殊步骤" tabindex="-1"><a class="header-anchor" href="#_3-特殊步骤" aria-hidden="true">#</a> 3.特殊步骤</h4><p>有些上线流程特殊值很多，难以通过封装的方法提取公共点，所以如有特殊情况，可去修改源码。 <img src="https://i1.letvimg.com/lc16_lemf/202311/23/16/36/Snipaste_2023-11-23_16-35-08.png" alt=""><br> 填写完毕后，以步骤的 key 为基本，可以删除或者修改步骤的顺序。<br> 对于后端来说，<strong>一个个步骤就是一个对象，完整的流程就是一个对象数组</strong>，和上线项目、上线分支等结合起来，就是一个完整的项目上线流程。</p><h3 id="四、执行上线与保存日志" tabindex="-1"><a class="header-anchor" href="#四、执行上线与保存日志" aria-hidden="true">#</a> 四、执行上线与保存日志</h3><p>前端发起请求之后，<code>socket.io</code> 建立连接，寻找数据库中对于的上线流程，一步步执行下来，只有上一步成功了才会继续下一步。<br> 执行的过程中，一边把日志以 <code>websocket</code> 的方式实时传输到前端，一边保存到日志库里，方便后续查询。 上线日志一开始用的是 <code>node</code> 原生的 <code>spawn</code> 或者 <code>exec</code>，体验下来感官并不好，不仅慢，数据是一堆一堆出来的，而且会损失日志内容。<br> 后来查到了 <code>node-pty</code> 这个库，原本似乎是 <code>node</code> 端用来模拟终端的。<code>node-pty</code> 下面的 <code>spawn</code> 方法可以监听流式传输的内容，并且速度快且不损失内容，还能保留字符的 anti 码，可以完整地还原日志的字号、颜色等。 <img src="https://i2.letvimg.com/lc15_lemf/202311/23/16/49/Snipaste_2023-11-23_16-48-52.png" alt=""></p>',18),r=[t];function i(n,h){return c(),o("div",null,r)}const p=e(a,[["render",i],["__file","deploy.html.vue"]]);export{p as default};
