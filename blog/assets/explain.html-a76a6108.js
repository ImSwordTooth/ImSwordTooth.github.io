import{_ as d,r,M as a,p,q as m,Q as n,t as e,N as t,V as s,a1 as _}from"./framework-e799b403.js";const k=n("h1",{id:"注解-explain",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#注解-explain","aria-hidden":"true"},"#"),e(" 注解 - Explain")],-1),h=n("p",null,"overscroll-behavior 是CSS的新属性，允许开发者覆盖默认的浏览器滚动行为，有三个值：",-1),v=n("li",null,[n("strong",null,"auto"),e("：其认值。元素（容器）的滚动会传播给其祖先元素。有点类似 JavaScript 中的冒泡行为。")],-1),x=n("strong",null,"contain",-1),g=n("code",null,"overscroll-behavior:contain",-1),b=n("li",null,[n("strong",null,"none"),e("：和 contain 一样，但它也可以防止节点本身的滚动效果。 也可以设置 "),n("code",null,"overscroll-behavior-x"),e(" 和 "),n("code",null,"overscroll-behavior-y"),e(" 来分别设置两个方向上的滚动行为。")],-1),f=n("hr",null,null,-1),y=n("ul",null,[n("li",null,"不占据文档的布局，阅读注释时也不会打扰正式内容的进度"),n("li",null,[e("基本支持所有 markdown 文件，可以手写，也可以"),n("code",null,"require"),e("一个现成的"),n("code",null,".md"),e("文件")])],-1),C=_("<ol><li>给文本添加一个<code>mouseover</code>事件</li><li>触发后，使用<code>showdown</code>库把传入的<code>md</code>转成<code>html</code>字符串</li><li>把<code>html</code>字符串放到<code>body</code>元素上，但是隐藏不显示，获取其高度后移除</li><li>把<code>html</code>字符串和高度放到<code>data</code>里，以对应的 vue 组件的 <code>v-html</code> 和 <code>:style</code></li></ol>",1),w=n("div",{class:"language-vue line-numbers-mode","data-ext":"vue"},[n("pre",{class:"language-vue"},[n("code",null,[n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"<"),e("Explain")]),e(),n("span",{class:"token attr-name"},"text"),n("span",{class:"token attr-value"},[n("span",{class:"token punctuation attr-equals"},"="),n("span",{class:"token punctuation"},'"'),e("markdown 语法"),n("span",{class:"token punctuation"},'"')]),e(),n("span",{class:"token attr-name"},":md"),n("span",{class:"token attr-value"},[n("span",{class:"token punctuation attr-equals"},"="),n("span",{class:"token punctuation"},'"'),e("`# 我是一级标题`"),n("span",{class:"token punctuation"},'"')]),n("span",{class:"token punctuation"},">")]),n("span",{class:"token tag"},[n("span",{class:"token tag"},[n("span",{class:"token punctuation"},"</"),e("Explain")]),n("span",{class:"token punctuation"},">")]),e(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"})])],-1),E=n("div",{class:"language-typescript line-numbers-mode","data-ext":"ts"},[n("pre",{class:"language-typescript"},[n("code",null,[n("span",{class:"token keyword"},"interface"),e(),n("span",{class:"token class-name"},"Explain"),e(),n("span",{class:"token punctuation"},"{"),e(`
    text`),n("span",{class:"token operator"},":"),e(),n("span",{class:"token builtin"},"string"),n("span",{class:"token punctuation"},";"),e(),n("span",{class:"token comment"},"// 要解释的词语文本"),e(`
	md`),n("span",{class:"token operator"},":"),e(),n("span",{class:"token builtin"},"string"),n("span",{class:"token punctuation"},";"),e(),n("span",{class:"token comment"},"// 释义文本"),e(`
`),n("span",{class:"token punctuation"},"}"),e(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),S={__name:"explain.html",setup(q){const i=r(`# 一级标题
## 二级标题
### 三级标题
**粗**、*斜*

|属性|说明|
|---|---|
|我是表格|我是\`代码\`|
`);return(N,V)=>{const o=a("Explain"),l=a("PartTitle"),c=a("CodeGroupItem"),u=a("CodeGroup");return p(),m("div",null,[k,n("blockquote",null,[h,n("ul",null,[v,n("li",null,[x,e("：阻止"),t(o,{text:"滚动链接",md:"**滚动链接**：比如我们常见的APP中的抽屉式导航，有大量的条目，用户不得不滚动浏览器。当它们到达底部时，溢出容器停止滚动，因为没有更多的内容可以使用。换句话说，我们期望的效果是：滚动到底部时，滚动停止，因为我们到达了“滚动边界”（Scroll Boundary）。但是事实上，在Web页面中滚动并不会停止，而是继续滚动抽屉后面的内容。这种行为，我们称之为滚动链接（Scroll Chaining）。"}),e("。 滚动行为不会传播给其祖先元素，但会影响节点内的局部显示。例如，Android 上的光辉效果或 iOS 上的回弹效果。当用户触摸滚动边界时会通知用户。注意，"),g,e(" 在 html 元素上使用，可以阻止导航滚动操作。")]),b])]),f,n("div",null,[e(" 支持大部分"),t(o,{text:"markdown 语法",md:i.value},null,8,["md"]),e("。 ")]),t(l,{type:"good"}),y,t(l,{type:"code"}),C,t(u,null,{default:s(()=>[t(c,{title:"用法"},{default:s(()=>[w]),_:1}),t(c,{title:"props"},{default:s(()=>[E]),_:1})]),_:1})])}}},G=d(S,[["__file","explain.html.vue"]]);export{G as default};
